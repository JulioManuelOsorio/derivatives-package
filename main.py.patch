# Patch generated by Pyment v0.3.3

--- a/main.py
+++ b/main.py
@@ -5,6 +5,7 @@
 
 
 class Option:
+    """ """
     def __init__(self, r, S, K, T, sigma, type="C", t=0, flag = "EUR"):
         self.r = r
         if S >= 0:
@@ -31,36 +32,82 @@
         self.flag = flag
 
     def get_tau(self):
+        """ """
         return self.T - self.t
 
     def get_d1(self):
+        """ """
         return (np.log(self.S/self.K) + (self.r + self.sigma**2/2)*self.get_tau())/(self.sigma*np.sqrt(self.get_tau()))
 
     def get_d2(self):
+        """ """
         return self.get_d1() - self.sigma*np.sqrt(self.get_tau())
 
     def get_payoff(self, S_t):
+        """
+
+        :param S_t: 
+
+        
+        """
         if self.type == "C":
             return max(S_t - self.K, 0)
         else:
             return max(self.K - S_t, 0)
     
     def get_CRR_dt(self, N):
+        """
+
+        :param N: 
+
+        
+        """
         return self.get_tau()/N
     
     def get_CRR_df(self, N):
+        """
+
+        :param N: 
+
+        
+        """
         return math.exp(-self.r*self.get_CRR_dt(N))
     
     def get_CRR_u(self, N):
+        """
+
+        :param N: 
+
+        
+        """
         return math.exp(self.sigma*math.sqrt(self.get_CRR_dt(N)))
     
     def get_CRR_d(self, N):
+        """
+
+        :param N: 
+
+        
+        """
         return 1/self.get_CRR_u(N)
     
     def get_CRR_p(self, N):
+        """
+
+        :param N: 
+
+        
+        """
         return (math.exp(self.r*self.get_CRR_dt(N) - self.get_CRR_d(N)))/(self.get_CRR_u(N) - self.get_CRR_d(N))
     
     def get_price(self, solver, N = None):
+        """
+
+        :param solver: 
+        :param N:  (Default value = None)
+
+        
+        """
         if solver == "BSM":
             if self.type == "C":
                 return self.S*norm.cdf(self.get_d1(), 0, 1) - self.K*np.exp(-self.r*self.get_tau())*norm.cdf(self.get_d2(), 0, 1)
@@ -78,6 +125,15 @@
             return a*math.exp(-self.r*self*self.get_tau())
             
     def plot_convergence(solver, step, max_time, min_time = 1):
+        """
+
+        :param solver: 
+        :param step: 
+        :param max_time: 
+        :param min_time:  (Default value = 1)
+
+        
+        """
         if solver == "CRR":
             bsm_price = self.get_price(solver = "BSM")
             times = range(min_time, max_time, step)
@@ -93,30 +149,42 @@
             
             
     def get_delta(self):
+        """ """
         if self.type == "C":
             return norm.cdf(self.get_d1(), 0, 1)
         else:
             return -norm.cdf(-self.get_d1(), 0, 1)
 
     def get_gamma(self):
+        """ """
         return norm.pdf(self.get_d1(), 0, 1)/(self.S*self.sigma*np.sqrt(self.get_tau()))
 
     def get_theta(self):
+        """ """
         if self.type == "C":
             return -self.S*norm.pdf(self.get_d1(), 0, 1)*self.sigma/(2*np.sqrt(self.get_tau())) - self.r*self.K*math.exp(-self.r*self.get_tau())*norm.cdf(self.get_d2(), 0, 1)
         else:
             return self.K*math.exp(-self.r*self.get_tau())*norm.cdf(-self.get_d2(), 0, 1) - self.S*norm.cdf(-self.get_d1(), 0, 1)
 
     def get_vega(self):
+        """ """
         return self.S*norm.pdf(self.get_d1(), 0, 1)*np.sqrt(self.get_tau())
 
     def get_rho(self):
+        """ """
         if self.type == "C":
             return self.K*self.get_tau()*math.exp(-self.r*self.get_tau())*norm.cdf(self.get_d2(), 0, 1)
         else:
             return -self.K*self.get_tau()*math.exp(-self.r*self.get_tau())*norm.cdf(-self.get_d2(), 0, 1)
         
 def comb(n,i):
+    """
+
+    :param n: 
+    :param i: 
+
+    
+    """
     return math.factorial(n)/(math.factorial(n - i)*math.factorial(i))
         
         